# Новые сигналы в агентных системах

## Контекст
**Hugging Face `smolagents`** (Релиз: Январь-Февраль 2025)

## Наблюдение
Архитектурное разделение агентов на два явных класса: `CodeAgent` и `ToolCallingAgent`.
`CodeAgent` становится основным рекомендованным примитивом: вместо генерации JSON для вызова инструментов (стандарт индустрии), агент генерирует исполняемый Python-код.
Этот код выполняется в локальной песочнице (sandbox) и может содержать циклы, переменные и сложную логику обработки данных между вызовами инструментов.

## Причина
JSON-based tool calling ("Tool calling") обладает низкой "выразительностью" (low expressivity). Агенты, работающие через JSON, с трудом справляются задачами, требующими передачи выходных данных одного инструмента на вход другому с предварительной обработкой (фильтрация, агрегация). Генерация кода позволяет агенту самому писать "склеивающую" логику, уменьшая количество необходимых шагов (round-trips) к LLM.

## Следствие
Смена парадигмы с "Агент как диспетчер API" (JSON) на "Агент как разработчик" (Code Generation). Это повышает автономность агентов в задачах анализа данных и многошаговых процессов, но требует жесткой изоляции среды исполнения (Sandboxing) из-за рисков выполнения произвольного кода.

## Источники
- [Hugging Face: Agents - Guided Tour](https://huggingface.co/docs/smolagents/guided_tour)
- [Smolagents Blog: Simplifying AI Agent Development](https://smolagents.org/smolagents-simplifying-ai-agent-development/)

---

## Контекст
**PydanticAI: Control Flow Architecture** (Документация и Engineering Blog)

## Наблюдение
Явный отказ от использования графовых DSL (Domain Specific Languages) как основного способа оркестрации агентов.
В отличие от LangGraph, где логика агента описывается через узлы и ребра графа, PydanticAI продвигает использование стандартного Python (`async def`, `if/else`, `while`) для управления потоком выполнения. Графы (`pydantic_graph`) предлагаются только для самых сложных сценариев с циклическими зависимостями, где обычный код становится запутанным.

## Причина
Графовые абстракции создают излишнюю когнитивную нагрузку и усложняют отладку ("Graph spaghetti"). Использование нативных конструкций языка в сочетании с Dependency Injection (`RunContext`) позволяет использовать стандартные инструменты тестирования и линтинга, снижая порог входа.

## Следствие
Упрощение архитектуры агентных приложений ("Plain Python over Frameworks"). Индустрия отходит от создания сложных "языков внутри языка" для управления агентами в пользу использования возможностей самого языка программирования, усиленных строгой типизацией.

## Источники
- [Pydantic AI Documentation: Graphs](https://ai.pydantic.dev/graph/)
- [ZenML Blog: Pydantic AI vs LangGraph](https://www.zenml.io/blog/pydantic-ai-vs-langgraph)

---

## Контекст
**Внедрение Model Context Protocol (MCP)** (PydanticAI, CrewAI, Anthropic)

## Наблюдение
Массовая интеграция стандарта MCP (Model Context Protocol) в основные фреймворки (PydanticAI, CrewAI) как нативного способа подключения инструментов.
Вместо написания кастомных "оберток" для каждого API, фреймворки переходят на поддержку универсальных MCP-клиентов, которые могут подключаться к любым MCP-серверам (базы данных, файловые системы, сервисы).

## Причина
Проблема масштабируемости интеграций ("m x n problem"): разработчикам приходилось писать адаптеры для каждого инструмента под каждый фреймворк. MCP стандартизирует протокол обнаружения и вызова инструментов.

## Следствие
Коммодитизация инструментов (Tools). Инструменты становятся независимыми от агентного фреймворка. Один и тот же MCP-сервер (например, для доступа к PostgreSQL) может быть использован агентом на Claude Desktop, PydanticAI или CrewAI без изменения кода.

## Источники
- [Pydantic AI Docs: MCP](https://ai.pydantic.dev/mcp/overview/)
- [CrewAI MCP Integration Announcement](https://community.crewai.com/t/crewai-mcp-integration-live-in-docs/5879)
